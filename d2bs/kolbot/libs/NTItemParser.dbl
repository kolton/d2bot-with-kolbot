/*

[Item-parser Syntax Information]

1. [Keyword] separates into two groups
   - [Property Keywords] : [Type], [Name], [Class], [Quality], [Flag], [Level], [Prefix], [Suffix]
   - [Stat Keywords] : [Number or Alias]

2. [Keyword] must be surrounded by '[' and ']'

3. [Property Keywords] must be placed first

4. Insert '#' symbol between [Property Keywords] and [Stat Keywords]

5. Use '+', '-', '*', '/', '(', ')', '&&', '||', '>', '>=', '<', '<=', '==', '!=' symbols for comparison

6. Use '//' symbol for comment

*/

include("NTItemAlias.dbl");

var NTIP = {},
	NTIP_CheckList = [],
	stringArray = [];

NTIP.OpenFile = function (filepath, notify) {
	if (!FileTools.exists(filepath)) {
		if (notify) {
			Misc.errorReport("ÿc1NIP file doesn't exist: ÿc0" + filepath);
		}

		return false;
	}

	var i, nipfile, line, lines, info, item,
		hash = md5_file(filepath),
		filename = filepath.substring(filepath.lastIndexOf("/") + 1, filepath.length),
		entries = 0;

	if (!FileTools.exists("pickit/minified/" + hash + "." + filename)) {
		NTIP.Minify(filepath);
	}

	if (FileTools.exists("pickit/minified/" + hash + "." + filename)) {
		filepath = "pickit/minified/" + hash + "." + filename;
	}

	try {
		nipfile = File.open(filepath, 0);
	} catch (fileError) {
		if (notify) {
			Misc.errorReport("ÿc1Failed to load NIP: ÿc0" + filename);
		}
	}

	if (!nipfile) {
		return false;
	}

	lines = nipfile.readAllLines();
	//item = me.getItem();

	nipfile.close();

	var tick = getTickCount();

	for (i = 0; i < lines.length; i += 1) {
		info = {
			line: i + 1,
			file: filename,
			string: lines[i]
		};

		line = NTIP.ParseLineInt(lines[i], info);

		// frickaline try/catch method
		// switching to this would mean adding a separate check for runeword entries
		/*if (line) {
			try {
				if (line[0] && line[0].length) {
					eval(line[0]);
				}

				if (line[1] && line[1].length) {
					eval(line[1]);
				}

				if (line[2] && line[2].length) {
					eval(line[2]);
				}
			} catch (lineError) {
				Misc.errorReport("Bad Line: " + lines[i]);
				
				line = false;
			}
		}*/

		if (line) {
			entries += 1;

			NTIP_CheckList.push(line);
			stringArray.push(info);
		}
	}

	print(getTickCount() - tick);

	if (notify) {
		print("ÿc4Loaded NIP: ÿc2" + filename + "ÿc4. Lines: ÿc2" + lines.length + "ÿc4. Valid entries: ÿc2" + entries);
	}

	return true;
};

NTIP.Minify = function (filepath) {
	var i, nipfile, lines, hash,
		filename = filepath.substring(filepath.lastIndexOf("/") + 1, filepath.length);

	try {
		nipfile = File.open(filepath, 0);
	} catch (fileError) {

	}

	if (!nipfile) {
		return false;
	}

	hash = md5_file(filepath);
	lines = nipfile.readAllLines();

	nipfile.close();

	for (i = 0; i < lines.length; i += 1) {
		lines[i] = lines[i].replace(/\s+/g, "").toLowerCase();
	}

	Misc.fileAction("pickit/minified/" + hash + "." + filename, 1, lines.join("\n"));

	return true;
};

NTIP.CheckQuantityOwned = function (item_type, item_stats) {
	var i, item,
		num = 0,
		items = me.getItems();

	if (!items) {
		print("I can't find my items!");

		return 0;
	}

	for (i = 0; i < items.length; i += 1) {
		if (items[i].mode === 0 && items[i].location === 7) {
			item = items[i];

			if ((item_type !== null && item_type.length > 0 && eval(item_type)) || item_type === null) {
				if ((item_stats !== null && item_stats.length > 0 && eval(item_stats)) || item_stats === null) {
					num += 1;
				}
			}
		} else if (items[i].mode === 0 && items[i].location === 3) { // inv check
			item = items[i];

			if ((item_type !== null && item_type.length > 0 && eval(item_type)) || item_type === null) {
				if ((item_stats !== null && item_stats.length > 0 && eval(item_stats)) || item_stats === null) {
					if (Config.Inventory[items[i].y][items[i].x] > 0) { // we check only space that is supposed to be free
						num += 1;
					}
				}
			}
		}
	}

	//print("I have "+num+" of these.");

	return num;
};

NTIP.Clear = function () {
	NTIP_CheckList = [];
	stringArray = [];
};

NTIP.CheckItem = function (item, entryList, verbose) {
	var i, list, identified, num,
		result = 0;

	if (!entryList) {
		list = NTIP_CheckList;
	} else {
		list = entryList;
	}

	identified = item.getFlag(0x10);

	for (i = 0; i < list.length; i += 1) {
		try {
			if (list[i][0].length > 0) {
				if (eval(list[i][0])) {
					if (list[i][1].length > 0) {
						if (eval(list[i][1])) {
							if (list[i][2] && list[i][2].MaxQuantity && !isNaN(list[i][2].MaxQuantity)) {
								num = NTIP.CheckQuantityOwned(list[i][0], list[i][1]);

								if (num < list[i][2].MaxQuantity) {
									result = 1;

									break;
								} else {
									if (item.getParent() && item.getParent().name === me.name && item.mode === 0 && num === list[i][2].MaxQuantity) { // attempt at inv fix for maxquantity
										result = 1;

										break;
									}
								}
							} else {
								result = 1;

								break;
							}
						} else if (!identified && result === 0) {
							result = -1;
						}
					} else {
						if (list[i][2] && list[i][2].MaxQuantity && !isNaN(list[i][2].MaxQuantity)) {
							num = NTIP.CheckQuantityOwned(list[i][0], null);

							if (num < list[i][2].MaxQuantity) {
								result = 1;

								break;
							} else {
								if (item.getParent() && item.getParent().name === me.name && item.mode === 0 && num === list[i][2].MaxQuantity) { // attempt at inv fix for maxquantity
									result = 1;

									break;
								}
							}
						} else {
							result = 1;

							break;
						}
					}
				}
			} else if (list[i][1].length > 0) {
				if (eval(list[i][1])) {
					if (list[i][2] && list[i][2].MaxQuantity && !isNaN(list[i][2].MaxQuantity)) {
						num = NTIP.CheckQuantityOwned(null, list[i][1]);

						if (num < list[i][2].MaxQuantity) {
							result = 1;

							break;
						} else {
							if (item.getParent() && item.getParent().name === me.name && item.mode === 0 && num === list[i][2].MaxQuantity) { // attempt at inv fix for maxquantity
								result = 1;

								break;
							}
						}
					} else {
						result = 1;

						break;
					}
				} else if (!identified && result === 0) {
					result = -1;
				}
			}
		} catch (pickError) {
			showConsole();

			if (!entryList) {
				Misc.errorReport("ÿc1Pickit error! Line # ÿc2" + stringArray[i].line + " ÿc1Entry: ÿc0" + stringArray[i].string + " (" + stringArray[i].file + ")");

				NTIP_CheckList[i] = ["", "", ""]; // make the bad entry blank
			} else {
				Misc.errorReport("ÿc1Pickit error in runeword config!");
			}

			result = 0;
		}
	}

	if (verbose) {
		if (result > 0) {
			return {line: stringArray[i].file + " #" + stringArray[i].line, result: result};
		}

		return {line: null, result: result};
	}

	return result;
};

NTIP.IsSyntaxInt = function (ch) {
	return (ch === '!' || ch === '%' || ch === '&' || (ch >= '(' && ch <= '+') || ch === '-' || ch === '/' || (ch >= ':' && ch <= '?') || ch === '|');
};

NTIP.ParseLineInt = function (input, info) {
	var i, property, p_start, p_end, p_section, p_keyword, p_result, p_quantity;

	p_end = input.indexOf("//");

	if (p_end !== -1) {
		input = input.substring(0, p_end);
	}

	input = input.replace(/\s+/g, "").toLowerCase();

	if (input.length < 5) {
		return null;
	}

	p_result = input.split("#");

	if (p_result[0] && p_result[0].length > 4) {
		p_section = p_result[0].split("[");

		p_result[0] = p_section[0];

		for (i = 1; i < p_section.length; i += 1) {
			p_end = p_section[i].indexOf("]") + 1;
			property = p_section[i].substring(0, p_end - 1);

			switch (property) {
			case 'color':
				p_result[0] += "item.getColor()";

				break;
			case 'type':
				p_result[0] += "item.itemType";

				break;
			case 'name':
				p_result[0] += "item.classid";

				break;
			case 'class':
				p_result[0] += "item.itemclass";

				break;
			case 'quality':
				p_result[0] += "item.quality";

				break;
			case 'flag':
				if (p_section[i][p_end] === '!') {
					p_result[0] += "!item.getFlag(";
				} else {
					p_result[0] += "item.getFlag(";
				}

				p_end += 2;

				break;
			case 'level':
				p_result[0] += "item.ilvl";

				break;
			case 'prefix':
				if (p_section[i][p_end] === '!') {
					p_result[0] += "!item.getPrefix(";
				} else {
					p_result[0] += "item.getPrefix(";
				}

				p_end += 2;

				break;
			case 'suffix':
				if (p_section[i][p_end] === '!') {
					p_result[0] += "!item.getSuffix(";
				} else {
					p_result[0] += "item.getSuffix(";
				}

				p_end += 2;

				break;
			default:
				Misc.errorReport("Unknown Keyword : " + property + " File: " + info.file + " Line: " + info.line);

				break;
			}

			for (p_start = p_end; p_end < p_section[i].length; p_end += 1) {
				if (!NTIP.IsSyntaxInt(p_section[i][p_end])) {
					break;
				}
			}

			p_result[0] += p_section[i].substring(p_start, p_end);

			for (p_start = p_end; p_end < p_section[i].length; p_end += 1) {
				if (NTIP.IsSyntaxInt(p_section[i][p_end])) {
					break;
				}
			}

			p_keyword = p_section[i].substring(p_start, p_end);

			if (isNaN(p_keyword)) {
				switch (property) {
				case 'color':
					if (typeof NTIPAliasColor[p_keyword] === "undefined") {
						Misc.errorReport("Unknown color: " + p_keyword + " File: " + info.file + " Line: " + info.line);
						p_result[0] += "false";
					} else {
						p_result[0] += NTIPAliasColor[p_keyword];
					}

					break;
				case 'type':
					if (typeof NTIPAliasType[p_keyword] === "undefined") {
						Misc.errorReport("Unknown type: " + p_keyword + " File: " + info.file + " Line: " + info.line);
						p_result[0] += "false";
					} else {
						p_result[0] += NTIPAliasType[p_keyword];
					}

					break;
				case 'name':
					if (typeof NTIPAliasClassID[p_keyword] === "undefined") {
						Misc.errorReport("Unknown name: " + p_keyword + " File: " + info.file + " Line: " + info.line);
						p_result[0] += "false";
					} else {
						p_result[0] += NTIPAliasClassID[p_keyword];
					}

					break;
				case 'class':
					if (typeof NTIPAliasClass[p_keyword] === "undefined") {
						Misc.errorReport("Unknown class: " + p_keyword + " File: " + info.file + " Line: " + info.line);
						p_result[0] += "false";
					} else {
						p_result[0] += NTIPAliasClass[p_keyword];
					}

					break;
				case 'quality':
					if (typeof NTIPAliasQuality[p_keyword] === "undefined") {
						Misc.errorReport("Unknown quality: " + p_keyword + " File: " + info.file + " Line: " + info.line);
						p_result[0] += "false";
					} else {
						p_result[0] += NTIPAliasQuality[p_keyword];
					}

					break;
				case 'flag':
					if (typeof NTIPAliasFlag[p_keyword] === "undefined") {
						Misc.errorReport("Unknown flag: " + p_keyword + " File: " + info.file + " Line: " + info.line);
						p_result[0] += "false)";
					} else {
						p_result[0] += NTIPAliasFlag[p_keyword] + ")";
					}

					break;
				}
			} else {
				if (property === 'flag' || property === 'prefix' || property === 'suffix') {
					p_result[0] += p_keyword + ")";
				} else {
					p_result[0] += p_keyword;
				}
			}

			p_result[0] += p_section[i].substring(p_end);
		}
	} else {
		p_result[0] = "";
	}

	if (p_result[1] && p_result[1].length > 4) {
		p_section = p_result[1].split("[");
		p_result[1] = p_section[0];

		for (i = 1; i < p_section.length; i += 1) {
			p_end = p_section[i].indexOf("]");
			p_keyword = p_section[i].substring(0, p_end);

			if (isNaN(p_keyword)) {
				if (typeof NTIPAliasStat[p_keyword] === "undefined") {
					Misc.errorReport("Unknown stat: " + p_keyword + " File: " + info.file + " Line: " + info.line);
					p_result[1] += "false";
				} else {
					p_result[1] += "item.getStatEx(" + NTIPAliasStat[p_keyword] + ")";
				}
			} else {
				p_result[1] += "item.getStatEx(" + p_keyword + ")";
			}

			p_result[1] += p_section[i].substring(p_end + 1);
		}
	} else {
		p_result[1] = "";
	}

	if (p_result[2] && p_result[2].replace(/^\s+|\s+$/, "").length > 0) {
		p_section = p_result[2].split("[");
		p_result[2] = [];

		for (i = 1; i < p_section.length; i += 1) {
			p_end = p_section[i].indexOf("]");
			p_keyword = p_section[i].substring(0, p_end);

			if (p_keyword.toLowerCase().replace(/^\s+|\s+$/, "") === "maxquantity") {
				p_end = p_section[i].split("==")[1].replace(/^\s+|\s+$/, "").indexOf("//");

				if (p_end === -1) {
					p_end = p_section[i].split("==")[1].replace(/^\s+|\s+$/, "").length;
				}

				p_quantity = Number(p_section[i].split("==")[1].replace(/^\s+|\s+$/, "").substring(0, p_end));
				p_result[2].MaxQuantity = p_quantity;
			} else {
				Misc.errorReport("Error in your NIP file - unknown 3rd part keyword: " + p_keyword.toLowerCase().replace(/^\s+|\s+$/, ""));
			}
		}
	}

	return p_result;
};